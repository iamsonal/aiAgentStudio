/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Copyright (c) 2025 Sonal
 */

/**
 * @description Validates tool dependencies at runtime before execution.
 * Uses the pre-compiled dependency graph stored on AIAgentDefinition__c to ensure
 * tools are executed in the correct order, preventing hallucination-induced sequencing errors.
 *
 * The dependency graph is generated by LLM analysis at design-time and approved by admin.
 * At runtime, this validator checks if all required predecessor tools have been executed
 * before allowing a tool to run.
 */
public inherited sharing class ToolDependencyValidator {
    private static final String LOG_PREFIX = '[ToolDependencyValidator] ';

    /**
     * @description Represents conditional dependency requirements.
     * Supports AND logic (allOf) and OR logic (anyOf).
     */
    public class DependencyRequirements {
        public List<String> allOf { get; set; } // All must be executed (AND)
        public List<String> anyOf { get; set; } // At least one must be executed (OR)

        public DependencyRequirements() {
            this.allOf = new List<String>();
            this.anyOf = new List<String>();
        }

        public Boolean isEmpty() {
            return allOf.isEmpty() && anyOf.isEmpty();
        }
    }

    /**
     * @description Result of a dependency validation check.
     */
    public class ValidationResult {
        public Boolean allowed { get; private set; }
        public List<String> missingDependencies { get; private set; }
        public List<String> missingAnyOfGroups { get; private set; }
        public String errorMessage { get; private set; }
        public String guidanceForLLM { get; private set; }

        public ValidationResult(Boolean allowed) {
            this.allowed = allowed;
            this.missingDependencies = new List<String>();
            this.missingAnyOfGroups = new List<String>();
        }

        public ValidationResult(Boolean allowed, List<String> missing, List<String> missingGroups, String errorMsg, String guidance) {
            this.allowed = allowed;
            this.missingDependencies = missing;
            this.missingAnyOfGroups = missingGroups;
            this.errorMessage = errorMsg;
            this.guidanceForLLM = guidance;
        }
    }

    /**
     * @description Creates a successful validation result (tool allowed to execute).
     */
    public static ValidationResult createAllowedResult() {
        return new ValidationResult(true);
    }

    /**
     * @description Creates a blocked validation result with missing dependencies.
     */
    public static ValidationResult createBlockedResult(String toolName, List<String> missing, List<String> missingGroups, Set<String> executedTools) {
        String errorMsg = 'Cannot execute ' + toolName + '. Required dependencies not met.';
        String guidance = buildGuidanceForLLM(toolName, missing, missingGroups, executedTools);
        return new ValidationResult(false, missing, missingGroups, errorMsg, guidance);
    }

    /**
     * @description Builds a structured, actionable error message for the LLM to self-correct.
     */
    private static String buildGuidanceForLLM(String blockedTool, List<String> missingAllOf, List<String> missingAnyOfGroups, Set<String> executedTools) {
        String guidance = 'DEPENDENCY VIOLATION: Tool \'' + blockedTool + '\' cannot execute yet.\n\n';

        if (!missingAllOf.isEmpty()) {
            guidance += 'REQUIRED (ALL must be called FIRST):\n';
            for (String dep : missingAllOf) {
                guidance += '  • ' + dep + '\n';
            }
            guidance += '\n';
        }

        if (!missingAnyOfGroups.isEmpty()) {
            guidance += 'REQUIRED (call AT LEAST ONE):\n';
            for (String groupDesc : missingAnyOfGroups) {
                guidance += '  • ' + groupDesc + '\n';
            }
            guidance += '\n';
        }

        guidance += 'NEXT ACTION: Call the required tool(s) listed above in your next response. ';
        guidance += 'After they execute successfully, you can then call \'' + blockedTool + '\'.\n\n';

        if (!executedTools.isEmpty()) {
            List<String> executedList = new List<String>(executedTools);
            guidance += 'CONTEXT: Tools already executed: ' + String.join(executedList, ', ') + '\n';
        } else {
            guidance += 'CONTEXT: No tools have been executed yet. Start with the required tool(s) above.\n';
        }

        return guidance;
    }

    /**
     * @description Parsed dependency graph structure for efficient runtime lookups.
     */
    public class DependencyGraph {
        public String version { get; private set; }
        public Map<String, Object> dependencies { get; private set; }
        public Datetime generatedAt { get; private set; }

        public DependencyGraph() {
            this.dependencies = new Map<String, Object>();
        }

        /**
         * @description Gets the required dependencies for a given tool.
         * @return DependencyRequirements with allOf and anyOf lists.
         */
        public DependencyRequirements getDependenciesFor(String toolName) {
            DependencyRequirements reqs = new DependencyRequirements();

            if (String.isBlank(toolName) || !dependencies.containsKey(toolName)) {
                return reqs;
            }

            Object value = dependencies.get(toolName);

            // New format: {"allOf": [...], "anyOf": [...]}
            if (value instanceof Map<String, Object>) {
                Map<String, Object> depMap = (Map<String, Object>) value;

                if (depMap.containsKey('allOf') && depMap.get('allOf') != null) {
                    List<Object> allOfList = (List<Object>) depMap.get('allOf');
                    for (Object dep : allOfList) {
                        reqs.allOf.add(String.valueOf(dep));
                    }
                }

                if (depMap.containsKey('anyOf') && depMap.get('anyOf') != null) {
                    List<Object> anyOfList = (List<Object>) depMap.get('anyOf');
                    for (Object dep : anyOfList) {
                        reqs.anyOf.add(String.valueOf(dep));
                    }
                }
            }

            return reqs;
        }

        /**
         * @description Checks if the graph has any dependencies defined.
         */
        public Boolean hasDependencies() {
            return !dependencies.isEmpty();
        }

        /**
         * @description Gets all tool names that have dependencies defined.
         */
        public Set<String> getToolsWithDependencies() {
            return dependencies.keySet();
        }
    }

    /**
     * @description Validates whether a tool can be executed based on the dependency graph.
     *
     * @param capabilityName The name of the tool/capability being executed.
     * @param executedTools Set of tool names already executed in this session.
     * @param graphJson The dependency graph JSON from AIAgentDefinition__c.ToolDependencyGraph__c.
     * @return ValidationResult indicating if execution is allowed or blocked.
     */
    public static ValidationResult validate(String capabilityName, Set<String> executedTools, String graphJson) {
        // No graph = no validation = allowed
        if (String.isBlank(graphJson)) {
            return createAllowedResult();
        }

        // Parse the graph
        DependencyGraph graph;
        try {
            graph = parseGraph(graphJson);
        } catch (Exception e) {
            // If graph is malformed, log warning and allow execution
            System.debug(LoggingLevel.WARN, LOG_PREFIX + 'Failed to parse dependency graph: ' + e.getMessage());
            return createAllowedResult();
        }

        // No dependencies in graph = allowed
        if (!graph.hasDependencies()) {
            return createAllowedResult();
        }

        // Get dependencies for this tool
        DependencyRequirements required = graph.getDependenciesFor(capabilityName);

        // No dependencies for this specific tool = allowed
        if (required.isEmpty()) {
            return createAllowedResult();
        }

        // Check which allOf dependencies are missing
        List<String> missingAllOf = new List<String>();
        for (String dep : required.allOf) {
            if (!executedTools.contains(dep)) {
                missingAllOf.add(dep);
            }
        }

        // Check if anyOf requirement is satisfied (at least one executed)
        List<String> missingAnyOfGroups = new List<String>();
        if (!required.anyOf.isEmpty()) {
            Boolean anyMet = false;
            for (String dep : required.anyOf) {
                if (executedTools.contains(dep)) {
                    anyMet = true;
                    break;
                }
            }
            if (!anyMet) {
                missingAnyOfGroups.add('[Any of: ' + String.join(required.anyOf, ', ') + ']');
            }
        }

        // All dependencies satisfied = allowed
        if (missingAllOf.isEmpty() && missingAnyOfGroups.isEmpty()) {
            return createAllowedResult();
        }

        // Dependencies not met = blocked
        return createBlockedResult(capabilityName, missingAllOf, missingAnyOfGroups, executedTools);
    }

    /**
     * @description Parses the JSON dependency graph into a structured object.
     *
     * Expected JSON format:
     * {
     *   "version": "1.0",
     *   "generatedAt": "2026-01-25T10:30:00Z",
     *   "dependencies": {
     *     "update_record": {
     *       "allOf": ["get_record_details"],
     *       "anyOf": ["get_email", "get_phone"]
     *     },
     *     "send_email": {
     *       "allOf": ["update_record"]
     *     }
     *   }
     * }
     */
    public static DependencyGraph parseGraph(String graphJson) {
        DependencyGraph graph = new DependencyGraph();

        if (String.isBlank(graphJson)) {
            return graph;
        }

        Map<String, Object> parsed = (Map<String, Object>) JSON.deserializeUntyped(graphJson);

        // Version
        if (parsed.containsKey('version')) {
            graph.version = String.valueOf(parsed.get('version'));
        }

        // Timestamp (optional)
        if (parsed.containsKey('generatedAt') && parsed.get('generatedAt') != null) {
            try {
                String tsStr = String.valueOf(parsed.get('generatedAt'));
                // Handle ISO format: 2026-01-25T10:30:00Z
                tsStr = tsStr.replace('T', ' ').replace('Z', '');
                graph.generatedAt = Datetime.valueOf(tsStr);
            } catch (Exception e) {
                // Ignore invalid timestamp format
                System.debug(LoggingLevel.DEBUG, LOG_PREFIX + 'Could not parse timestamp: ' + e.getMessage());
            }
        }

        // Dependencies map
        if (parsed.containsKey('dependencies') && parsed.get('dependencies') != null) {
            Map<String, Object> depsMap = (Map<String, Object>) parsed.get('dependencies');
            graph.dependencies = depsMap;
        }

        return graph;
    }

    /**
     * @description Detects circular dependencies in a graph.
     * Used during graph generation to prevent infinite loops.
     *
     * @param graph The parsed dependency graph.
     * @return List of tool names involved in cycles, or empty list if no cycles.
     */
    public static List<String> detectCircularDependencies(DependencyGraph graph) {
        List<String> cyclicNodes = new List<String>();
        Set<String> visited = new Set<String>();
        Set<String> recursionStack = new Set<String>();

        for (String node : graph.dependencies.keySet()) {
            if (hasCycleDFS(node, graph, visited, recursionStack, cyclicNodes)) {
                // Cycle detected, cyclicNodes contains the involved nodes
            }
        }

        return cyclicNodes;
    }

    /**
     * @description DFS helper for cycle detection.
     */
    private static Boolean hasCycleDFS(String node, DependencyGraph graph, Set<String> visited, Set<String> recursionStack, List<String> cyclicNodes) {
        if (recursionStack.contains(node)) {
            if (!cyclicNodes.contains(node)) {
                cyclicNodes.add(node);
            }
            return true;
        }

        if (visited.contains(node)) {
            return false;
        }

        visited.add(node);
        recursionStack.add(node);

        DependencyRequirements reqs = graph.getDependenciesFor(node);

        // Check allOf dependencies
        for (String dep : reqs.allOf) {
            if (hasCycleDFS(dep, graph, visited, recursionStack, cyclicNodes)) {
                if (!cyclicNodes.contains(node)) {
                    cyclicNodes.add(node);
                }
                return true;
            }
        }

        // Check anyOf dependencies
        for (String dep : reqs.anyOf) {
            if (hasCycleDFS(dep, graph, visited, recursionStack, cyclicNodes)) {
                if (!cyclicNodes.contains(node)) {
                    cyclicNodes.add(node);
                }
                return true;
            }
        }

        recursionStack.remove(node);
        return false;
    }

    /**
     * @description Generates a hash of capability names for staleness detection.
     * Used to detect when capabilities have changed since the graph was generated.
     *
     * @param capabilities List of capability records.
     * @return A hash string representing the current capability configuration.
     */
    public static String generateCapabilitiesHash(List<AgentCapability__c> capabilities) {
        if (capabilities == null || capabilities.isEmpty()) {
            return '';
        }

        // Build stable signature list for consistent hashing
        List<String> capSignatures = new List<String>();
        for (AgentCapability__c cap : capabilities) {
            // Only include enabled capabilities
            if (cap.ExposureLevel__c != 'Disabled') {
                String signature = String.join(
                    new List<String>{
                        String.valueOf(cap.CapabilityName__c),
                        String.valueOf(cap.ExposureLevel__c),
                        String.valueOf(cap.RunAsynchronously__c),
                        String.valueOf(cap.HITLMode__c),
                        String.valueOf(cap.ImplementationType__c),
                        String.valueOf(cap.StandardActionType__c),
                        String.valueOf(cap.ImplementationDetail__c),
                        String.valueOf(cap.Parameters__c)
                    },
                    '|'
                );
                capSignatures.add(signature);
            }
        }
        capSignatures.sort();

        // Create hash from sorted signatures
        String combined = String.join(capSignatures, '||');
        Blob hashBlob = Crypto.generateDigest('SHA-256', Blob.valueOf(combined));
        return EncodingUtil.convertToHex(hashBlob).left(32);
    }

    /**
     * @description Checks if the dependency graph is stale based on capability hash comparison.
     *
     * @param currentHash The current capabilities hash.
     * @param storedHash The hash stored when the graph was generated.
     * @return True if the graph is stale (hashes don't match).
     */
    public static Boolean isGraphStale(String currentHash, String storedHash) {
        if (String.isBlank(storedHash)) {
            return false; // No stored hash = no staleness check possible
        }
        return !currentHash.equals(storedHash);
    }

    /**
     * @description Performs topological sort on a list of tools based on dependency graph.
     * Returns tools in execution order where dependencies come before dependents.
     *
     * @param toolNames Set of tool names to sort.
     * @param graph The parsed dependency graph.
     * @param alreadyExecuted Set of tools already executed (considered satisfied).
     * @return Sorted list of tool names, or partial list if some have missing dependencies.
     */
    public static List<String> topologicalSort(Set<String> toolNames, DependencyGraph graph, Set<String> alreadyExecuted) {
        List<String> result = new List<String>();
        Set<String> visited = new Set<String>(alreadyExecuted);
        Set<String> visiting = new Set<String>();

        List<String> orderedToolNames = new List<String>(toolNames);
        orderedToolNames.sort();

        for (String toolName : orderedToolNames) {
            if (!visited.contains(toolName)) {
                topologicalSortVisit(toolName, graph, toolNames, visited, visiting, result, alreadyExecuted);
            }
        }

        return result;
    }

    /**
     * @description DFS visit for topological sort.
     */
    private static Boolean topologicalSortVisit(
        String toolName,
        DependencyGraph graph,
        Set<String> toolsInBatch,
        Set<String> visited,
        Set<String> visiting,
        List<String> result,
        Set<String> alreadyExecuted
    ) {
        if (visited.contains(toolName)) {
            return true;
        }

        if (visiting.contains(toolName)) {
            // Circular dependency - cannot sort
            System.debug(LoggingLevel.WARN, LOG_PREFIX + 'Circular dependency detected for tool: ' + toolName);
            return false;
        }

        visiting.add(toolName);

        // Check all dependencies
        DependencyRequirements reqs = graph.getDependenciesFor(toolName);

        // Check allOf dependencies (all must be satisfied)
        for (String dep : reqs.allOf) {
            // Dependency must be either already executed OR in the current batch
            if (!alreadyExecuted.contains(dep) && !toolsInBatch.contains(dep)) {
                // Missing dependency - cannot sort this tool
                System.debug(LoggingLevel.DEBUG, LOG_PREFIX + 'Tool "' + toolName + '" blocked - missing allOf dependency: ' + dep);
                visiting.remove(toolName);
                return false;
            }

            // If dependency is in batch, visit it first
            if (toolsInBatch.contains(dep) && !visited.contains(dep)) {
                Boolean canVisit = topologicalSortVisit(dep, graph, toolsInBatch, visited, visiting, result, alreadyExecuted);
                if (!canVisit) {
                    visiting.remove(toolName);
                    return false;
                }
            }
        }

        // Check anyOf dependencies (at least one must be satisfied)
        if (!reqs.anyOf.isEmpty()) {
            Boolean anyMet = false;

            // Strategy: Prefer already-satisfied dependencies first, then try batch candidates
            // This prevents blocking when one anyOf option is in batch but blocked

            // Check if any dependency is already satisfied
            for (String dep : reqs.anyOf) {
                if (alreadyExecuted.contains(dep)) {
                    anyMet = true;
                    break; // Already satisfied, no need to visit
                }
            }

            // If not already satisfied, try to visit candidates in the batch
            if (!anyMet) {
                for (String dep : reqs.anyOf) {
                    if (toolsInBatch.contains(dep) && !visited.contains(dep)) {
                        // Try to visit this candidate
                        Boolean canVisit = topologicalSortVisit(dep, graph, toolsInBatch, visited, visiting, result, alreadyExecuted);
                        if (canVisit) {
                            anyMet = true;
                            break; // Found a satisfiable path
                        }
                        // If this candidate can't be visited, try next anyOf option
                    } else if (toolsInBatch.contains(dep) && visited.contains(dep)) {
                        // Already visited in this batch
                        anyMet = true;
                        break;
                    }
                }
            }

            if (!anyMet) {
                System.debug(
                    LoggingLevel.DEBUG,
                    LOG_PREFIX + 'Tool "' + toolName + '" blocked - no satisfiable anyOf dependency found: ' + String.join(reqs.anyOf, ', ')
                );
                visiting.remove(toolName);
                return false;
            }
        }

        visiting.remove(toolName);
        visited.add(toolName);
        result.add(toolName);
        return true;
    }
}
